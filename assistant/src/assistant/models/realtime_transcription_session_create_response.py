# coding: utf-8

"""
OpenAI API

The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.

The version of the OpenAPI document: 2.3.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from assistant.models.realtime_session_create_response_turn_detection import RealtimeSessionCreateResponseTurnDetection
from assistant.models.realtime_transcription_session_create_response_client_secret import (
    RealtimeTranscriptionSessionCreateResponseClientSecret,
)
from assistant.models.realtime_transcription_session_create_response_input_audio_transcription import (
    RealtimeTranscriptionSessionCreateResponseInputAudioTranscription,
)

try:
    from typing import Self
except ImportError:
    from typing_extensions import Self


class RealtimeTranscriptionSessionCreateResponse(BaseModel):
    """
    A new Realtime transcription session configuration.  When a session is created on the server via REST API, the session object also contains an ephemeral key. Default TTL for keys is one minute. This  property is not present when a session is updated via the WebSocket API.
    """  # noqa: E501

    client_secret: RealtimeTranscriptionSessionCreateResponseClientSecret
    modalities: Optional[List[StrictStr]] = Field(
        default=None,
        description='The set of modalities the model can respond with. To disable audio, set this to ["text"]. ',
    )
    input_audio_format: Optional[StrictStr] = Field(
        default=None, description="The format of input audio. Options are `pcm16`, `g711_ulaw`, or `g711_alaw`. "
    )
    input_audio_transcription: Optional[RealtimeTranscriptionSessionCreateResponseInputAudioTranscription] = None
    turn_detection: Optional[RealtimeSessionCreateResponseTurnDetection] = None
    __properties: ClassVar[List[str]] = [
        "client_secret",
        "modalities",
        "input_audio_format",
        "input_audio_transcription",
        "turn_detection",
    ]

    @field_validator("modalities")
    def modalities_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        for i in value:
            if i not in (
                "text",
                "audio",
            ):
                raise ValueError("each list item must be one of ('text', 'audio')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Create an instance of RealtimeTranscriptionSessionCreateResponse from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        _dict = self.model_dump(
            by_alias=True,
            exclude={},
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of client_secret
        if self.client_secret:
            _dict["client_secret"] = self.client_secret.to_dict()
        # override the default output from pydantic by calling `to_dict()` of input_audio_transcription
        if self.input_audio_transcription:
            _dict["input_audio_transcription"] = self.input_audio_transcription.to_dict()
        # override the default output from pydantic by calling `to_dict()` of turn_detection
        if self.turn_detection:
            _dict["turn_detection"] = self.turn_detection.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Dict) -> Self:
        """Create an instance of RealtimeTranscriptionSessionCreateResponse from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate(
            {
                "client_secret": (
                    RealtimeTranscriptionSessionCreateResponseClientSecret.from_dict(obj.get("client_secret"))
                    if obj.get("client_secret") is not None
                    else None
                ),
                "modalities": obj.get("modalities"),
                "input_audio_format": obj.get("input_audio_format"),
                "input_audio_transcription": (
                    RealtimeTranscriptionSessionCreateResponseInputAudioTranscription.from_dict(
                        obj.get("input_audio_transcription")
                    )
                    if obj.get("input_audio_transcription") is not None
                    else None
                ),
                "turn_detection": (
                    RealtimeSessionCreateResponseTurnDetection.from_dict(obj.get("turn_detection"))
                    if obj.get("turn_detection") is not None
                    else None
                ),
            }
        )
        return _obj
